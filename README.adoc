// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: cloud-azure
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2019-08-01
:page-description: Learn how to deploy microservices to Azure Kubernetes Service (AKS).
:page-tags: ['Docker']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes-intro']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Deploying microservices to Azure Kubernetes Service
:page-seo-description: Find out how to deploy an app to Azure Kubernetes Service
:page-guide-category: microprofile
:guide-author: Open Liberty
:page-essential: false
= Deploying microservices to Azure Kubernetes Service

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form,
view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to deploy your microservices application to Azure Kubernetes Service (AKS).

:kube: Kubernetes
:hashtag: #
:win: WINDOWS
:mac: MAC
:linux: LINUX
:system-api: http://[system-EXTERNAL-IP]:9080/system/properties
:inventory-api: http://[inventory-EXTERNAL-IP]:9081/inventory/systems


// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn

You will learn how to deploy two microservices in Open Liberty containers to a {kube} cluster on
Azure Kubernetes Service (AKS).

Kubernetes is an open source container orchestrator that automates many tasks involved in 
deploying, managing, and scaling containerized applications. If you would like to learn
more about Kubernetes, check out the https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^]
guide.

There are different cloud-based solutions for running your workloads in a {kube} cluster. 
A cloud-based infrastructure enables you to focus on developing your microservices without 
worrying about details related to the servers you deploy them to. Using a cloud helps 
you to easily scale and serve your microservices in a high-availability setup.

Azure offers a managed {kube} service called Azure Kubernetes Service (AKS). AKS simplifies the process of running Kubernetes on Azure without 
needing to install or maintain your own Kubernetes control plane. It provides a hosted {kube} 
cluster that you can deploy your microservices to. You will use AKS with an Azure
Container Registry (ACR). ACR is a private registry that is used to store 
and distribute your container images. Note, since AKS is not free, there is a small
cost that is associated with deployig this application. See the official
https://azure.microsoft.com/en-us/pricing/details/kubernetes-service/[AKS pricing^] documentation for more details.

The two microservices that you'll be working with are called `system` and `inventory`. 
The `system` microservice returns the JVM system properties of the running container.  
The `inventory` microservice adds the properties from the `system` microservice to the inventory. 
This guide demonstrates how both microservices can run and communicate
in different isolated containers.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Before you begin, the following tools need to be installed:

* *Docker:* You need a containerization software for building containers. Kubernetes 
supports various container types, but you will use Docker in this guide. For installation 
instructions, refer to the official https://docs.docker.com/install/[Docker^] documentation.

* *Azure Subscription:* To run this guide, you will need an Azure subscription. Navigate to the 
https://azure.microsoft.com/en-us/pricing/purchase-options/pay-as-you-go/[Microsoft Azure Purchase Options^] 
to create an account with your email and start a Pay-As-You-Go subscription. 

* *Azure CLI:* You will need to use the Azure Command Line Interface (CLI). See the official
https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest[Install the Azure CLI^]
documentation for information about setting up the Azure CLI for your platform.

+
** To verify that the Azure CLI is installed correctly, run the following command:
+
[role=command]
```
az --version
```

* *kubectl:* You need the Kubernetes command-line tool `kubectl` to interact with your Kubernetes cluster.
Use the Azure CLI to download and install `kubectl` with the following command:

+
[role=command]
```
az aks install-cli
```

To begin this guide, make sure that you are logged in to Azure to get access to your subscription:

[role=command]
```
az login
```

// =================================================================================================
// Getting started
// =================================================================================================

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Managing an Azure Container Registry
// =================================================================================================

== Managing an Azure Container Registry

In order to deploy your microservices, you need to create an Azure Container Registry in the same location
as where your services will be deployed. 

=== Creating a resource group

Your Azure Container Registry will be placed inside its own resource group that you will create.

A resource group is a logical collection of related resources that can be deployed and maintained as a single entity.
For instance, virtual machines, databases, and storage networks are types of resources that resource groups can be formed from.
Resource groups are dedicated to container registries because the resources in these registries are used by several 
different hosts and their containers. 

To create a resource group, an Azure location must be specified. The metadata for your resources are stored at this given location. 
If resources are created without specifying a location and created after creating a resource group, these new resources will run in the
same region specfied by the resource group location. 

See the list of available Azure regions for your Azure subscription:

[role=command]
```
az account list-locations -o table
```

The `name` column specifies the region name that you will be using to create your resource group


You will see an output similar to the following:

[role="no_copy"]
----
DisplayName          Latitude    Longitude    Name
-------------------  ----------  -----------  ------------------
Central US           41.5908     -93.6208     centralus
East US              37.3719     -79.8164     eastus
East US 2            36.6681     -78.3889     eastus2
West US              37.783      -122.417     westus
North Central US     41.8819     -87.6278     northcentralus
South Central US     29.4167     -98.5        southcentralus
Canada Central       43.653      -79.383      canadacentral
Canada East          46.817      -71.217      canadaeast
UK South             50.941      -0.799       uksouth
UK West              53.427      -3.084       ukwest
West Central US      40.890      -110.234     westcentralus
West US 2            47.233      -119.852     westus2
----

However, AKS is not available in all regions. Make sure that the region you select is 
https://azure.microsoft.com/en-us/global-infrastructure/services/?products=kubernetes-service[compatible with AKS^].

Create a resource group and replace `[location]` with a region that is available for your subscription and compatible with AKS.

[role=command]
```
az group create -l [location] -n guideGroup
```

You will see an output similar to the following:

[source, role="no_copy"]
```
{
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup",
  "location": "[location]",
  "managedBy": null,
  "name": "guideGroup",
  "properties": {
    "provisioningState": "Succeeded"
  },
  "tags": null,
  "type": null
}
```

=== Creating a container registry

Your private container registry will manage Docker images that you will build in later steps. 
With the Azure `az acr` command, create an Azure Container Registry.

[role=command]
```
az acr create -g guideGroup -n guideRegistry --sku Basic --admin-enabled
```

You will see an output similar to the following:

[role="no_copy"]
```
{
  "adminUserEnabled": true,
  "creationDate": "2019-06-05T20:28:09.637994+00:00",
  "id": "/subscriptions/[subscription-id]/resourceGroups/guideGroup/providers/Microsoft.ContainerRegistry/registries/guideRegistry",
  "location": "[location]",
  "loginServer": "guideregistry.azurecr.io",
  "name": "guideRegistry",
  "networkRuleSet": null,
  "provisioningState": "Succeeded",
  "resourceGroup": "guideGroup",
  "sku": {
    "name": "Basic",
    "tier": "Basic"
  },
  "status": null,
  "storageAccount": null,
  "tags": {},
  "type": "Microsoft.ContainerRegistry/registries"
}
```

In the `az acr create` command, the `-g` option specifies the resource group to designate to the container registry. 
You created this resource group before as `guideGroup`. The `-n` option specifies the name of the
container registry to be created, which was defined as `guideRegistry`. The `--admin-enabled` flag indicates that the admin user is enabled. 

The possible Stock Keeping Unit (SKU) values that can be passed into the `--sku` option are `Basic`, `Standard`, and `Premium`.
These different SKU options provide pricing for various levels of capacity and usage. Since your application involves a lower usage of
storage and image throughput, you are using a `Basic` SKU, due to its cost-optimized solution. 

Your container registry has a server name of `guideregistry.azurecr.io`. 

=== Logging into the container registry

You must log into your Azure Container Registry using the Azure CLI, in order to be able to push Docker images to your registry.

[role=command]
```
az acr login -n guideRegistry
```

Once you login, you will see the following:

[role="no_copy"]
----
Login Succeeded
----

Your login credentials will be needed later, so keep your given password in mind. View the credentials of your
Azure container registry:

[role=command]
```
az acr credential show -n guideRegistry
```

You will see an output similar to the following:

[role="no_copy"]
```
{
  "passwords": [
    {
      "name": "password",
      "value": "[password]"
    },
  ],
  "username": "guideRegistry"
}
```

// =================================================================================================
// Uploading images to a container registry
// =================================================================================================

== Uploading images to a container registry

=== Building your Docker images

The starting Java project, which you can find in the `start` directory, is a multi-module Maven
project. It is made up of the `system` and `inventory` microservices. Each microservice resides in its own directory,
`start/system` and `start/inventory`. Both of these directories contain a Dockerfile, which is necessary
for building the Docker images.

Navigate to the `start` directory and run the following command:

[role=command]
```
mvn install
```

Now that your microservices are packaged, you will build your 
Docker images using the `docker build` command. To build your image, you need to have Docker installed 
and your Docker daemon started.

Run the following commands to build and containerize the application:

[role='command']
```
docker build -t system system/.
docker build -t inventory inventory/.
```

To verify that the images are built, run the `docker images` command to list all local Docker images:

[role='command']
```
docker images
```

Your two images `inventory` and `system` should appear in the list of all Docker images:

[role="no_copy"]
----
REPOSITORY    TAG       IMAGE ID        CREATED          SIZE
inventory     latest    08fef024e986    4 minutes ago    471MB
system        latest    1dff6d0b4f31    5 minutes ago    470MB
----

=== Pushing the images to a container registry

Pushing the images to a registry allows the cluster to create pods by using your container images.

Tag your container images with your registry:

[role=command]
```
docker tag inventory:latest guideregistry.azurecr.io/inventory
docker tag system:latest guideregistry.azurecr.io/system
```

Finally, push your images to the registry:

[role=command]
```
docker push guideregistry.azurecr.io/inventory
docker push guideregistry.azurecr.io/system
```

// =================================================================================================
// Creating a Kubernetes cluster on AKS
// =================================================================================================

== Creating a Kubernetes cluster on AKS

=== Provisioning a cluster

To create your AKS cluster, use the `az aks create` cluster command. You might need to wait a while your
cluster is being created.

[role=command]
```
az aks create -g guideGroup --name guideCluster --generate-ssh-keys
```

Running this command creates an AKS cluster that is called `guideCluster` with the resource group
`guideGroup`. The `--generate-ssh-keys` option creates `SSH` key files, if they are missing,
and then stores them in the `~/.ssh` directory.

The option `--node-count -c` could also be added to this `az aks create` command to create a cluster
with a certain number of nodes in the Kubernetes node pool. By default, if this option is excluded,
three nodes will be assigned to the node pool.

An AKS cluster requires a service principal, which is a security credential that allows you to assign specific permissions
for Azure resources accessed by applications and services. The `az aks create` command automatically generates a service principal to use 
with your newly created cluster. However, in order to run this command, your Azure account must have permission access to create
service principals. 

Service principals can also be created manually with the `az ad sp create-for-rbac` command. This command outputs information about the
service principal, including an `appId` and `password`.
These two values can be passed into the `--service-principal` and `--client-secret` arguments in the cluster creation command, `az aks create`:

[role=command]
```
az aks create \
    -g guideGroup \
    -n guideCluster \
    --service-principal [appId] \
    --client-secret [password]
```

Once the cluster is created, the command outputs information about the cluster.

To view the credentials of your AKS cluster:

[role=command]
```
az aks get-credentials -g guideGroup -n guideCluster
```

You will see an output similar to the following:

[role="no_copy"]
----
Merged "guideCluster" as current context in /Users/.kube/config
----

Run the following command to check the status of the available nodes in your AKS cluster:

[role=command]
```
kubectl get nodes
```

The `kubectl get nodes` command outputs information about three nodes, as the cluster was created with the default number of nodes in a node pool.
The `STATUS` of each node is in the `Ready` state. 

[role="no_copy"]
----
NAME                       STATUS   ROLES   AGE     VERSION
aks-nodepool1-21407934-0   Ready    agent   2m25s   v1.12.8
aks-nodepool1-21407934-1   Ready    agent   2m48s   v1.12.8
aks-nodepool1-21407934-2   Ready    agent   2m34s   v1.12.8
----

=== Storing registry credentials in a secret

To be able to pull the images from your Azure container registry, the credentials of your registry must be added to your service
through a secret. 

Use the `kubectl create secret docker-registry` command to create a secret to hold your registry credentials. 
Replace `[password]` with the registry password thatyou viewed in the last section by running the 
`az acr credential show -n guideRegistry` command. The email that is associated with your Docker account should replace `[email-address]`.

[role=command]
```
kubectl create secret docker-registry guidesecret \
    --docker-server=guideregistry.azurecr.io \
    --docker-username=guideRegistry \
    --docker-password=[password] \
    --docker-email=[email-address]
```
The secret is successfully created with the following output:

[role="no_copy"]
----
secret/guidesecret created
----

// =================================================================================================
// Deploying microservices to AKS
// =================================================================================================

== Deploying microservices to AKS

=== Creating a deployment definition

Now that your container images are built, you can deploy them using a Kubernetes resource definition.

A Kubernetes resource definition is a `yaml` file that contains a description of all your 
deployments, services, or any other resources that you want to deploy. All resources can 
also be deleted from the cluster by using the same `yaml` file that you used to deploy them.
The [hotspot]`kubernetes.yaml` resource definition file is provided for you. If you are interested 
in learning more about the Kubernetes resource definition, check out the 
https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^]
guide.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `kubernetes.yaml`.#
`kubernetes.yaml`
----

kubernetes.yaml
[source, Text, linenums, indent=0, role="code_column"]
----
include::finish/kubernetes.yaml[]
----

The [hotspot=sysImage hotspot=invImage file=0]`image` is the name and tag of the container image that you want 
to use for the container. The [hotspot]`kubernetes.yaml` file references the images that you pushed to `guideRegistry`
for the [hotspot=sysImage file=0]`system` and [hotspot=invImage file=0]`inventory` repositories. These images can be pulled
with the [hotspot=sysSecret hotspot=invSecret file=0]`secret` that you defined before.

=== Deploying your application

In order to deploy your microservices to Azure Kubernetes Service, you need Kubernetes to create
the contents of the [hotspot]`kubernetes.yaml` file. 

Run the following command to deploy the resources defined in [hotspot]`kubernetes.yaml`:

[role='command']
```
kubectl create -f kubernetes.yaml
```

You will see an output similar to the following:

[role="no_copy"]
----
deployment.apps/system-deployment created
deployment.apps/inventory-deployment created
service/system-service created
service/inventory-service created
----

Run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

If all the pods are healthy and running, you see an output similar to the following:
[role="no_copy"]
----
NAME                                    READY     STATUS    RESTARTS   AGE
system-deployment-6bd97d9bf6-4ccds      1/1       Running   0          15s
inventory-deployment-645767664f-nbtd9   1/1       Running   0          15s
----

=== Making requests to the microservices

You will need the external IP addresses associated with `system` and `inventory` to try out your microservices.

Take note of the `EXTERNAL-IP` in the output of the following commands. It is the 
hostname you will later substitute into `[hostname]`.

[role='command']
```
kubectl get service/system-service -w
kubectl get service/inventory-service -w
```

The `-w` argument watches for changes about the service.

You will need to wait a while for the `EXTERNAL-IP` to change from `<pending>` to an IP address.

[role="no_copy"]
----
NAME             TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
system-service   LoadBalancer   10.0.27.66   <pending>     9080:32436/TCP   26s
----

[role="no_copy"]
----
NAME                TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
inventory-service   LoadBalancer   10.0.103.223   <pending>     9081:32739/TCP   69s
----

Once the `EXTERNAL-IP` appears, press `CTRL-C` for kubectl to stop watching the services. 

[role="no_copy"]
----
NAME             TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
system-service   LoadBalancer   10.0.27.66   23.99.223.10   9080:32436/TCP   74s
----

[role="no_copy"]
----
NAME             TYPE           CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
inventory-service   LoadBalancer   10.0.103.223   168.61.174.136   9081:32739/TCP   2m8s
----

To access the application and your microservices, point your browser to the following URLs, substituting the appropriate hostnames
for the `system` and `inventory` services:

- `{inventory-api}`
- `{system-api}`

The first URL returns an empty list is expected because no system properties are stored in the inventory yet. 

In the second URL, you see a result in JSON format with the system properties of your local JVM.

Point your browser to the `{inventory-api}/[system-EXTERNAL-IP]` URL. When you visit this URL, these system
properties are automatically stored in the inventory. Go back to `{inventory-api}` and
you see a new entry for `[system-EXTERNAL-IP]`.

// =================================================================================================
// Testing the microservices
// =================================================================================================

== Testing the microservices

pom.xml
[source, xml, linenums, role='code_column']
----
include::finish/pom.xml[tags=**]
----

The default properties that are defined in the [hotspot file=0]`pom.xml` file are:

[cols="15, 100", options="header"]
|===
| *Property*                      | *Description*
| [hotspot=sysKubeService file=0]`system.kube.service` | Name of the {kube} Service wrapping the `system` pods, `system-service` by default.
| [hotspot=invKubeService file=0]`inventory.kube.service` | Name of the {kube} Service wrapping the `inventory` pods, `inventory-service` by default.
| [hotspot=sysHttpPort file=0]`sys.service.http.port`    | The HTTP port for the {kube} Service `system-service`, 9080 by default.
| [hotspot=invHttpPort file=0]`inv.service.http.port`    | The HTTP port of the {kube} Service `inventory-service`, 9081 by default.
|===

You can test the basic functionality of your microservices. If a test failure
occurs, then you might have introduced a bug into the code. To run the tests, wait for all pods to be
in the ready state before you proceed further. 

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `SystemEndpointTest` class.#
`system/src/test/java/it/io/openliberty/guides/system/SystemEndpointTest.java`
----

SystemEndpointTest.java
[source, java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/system/src/test/java/it/io/openliberty/guides/system/SystemEndpointTest.java[]
----

The [hotspot=testGetProperties file=1]`testGetProperties()` method checks for a `200` response status from the `system` service endpoint.

[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `InventoryEndpointTest` class.#
`inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryEndpointTest.java`
----

InventoryEndpointTest.java
[source, java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryEndpointTest.java[]
----

* The [hotspot=testEmptyInventory file=2]`testEmptyInventory()` method checks that the `inventory` service has a total of 0 systems before anything is added to it.
* The [hotspot=testHostRegistration file=2]`testHostRegistration()` method checks that the `system` service was added to `inventory` properly.
* The [hotspot=testSystemPropertiesMatch file=2]`testSystemPropertiesMatch()` checks that the `system` properties match what was added into the `inventory`.
* The [hotspot=testUnknownHost file=2]`testUnknownHost()` checks that an error is raised if an unknown host name is being added into the `inventory` service.
* The [hotspot=sysServiceIp file=2]`systemServiceIp` is the same IP address value that you retrieved in the previous section that is assigned to the `system` service. This value will also be passed in when you run the tests. 
* The [hotspot=invServiceIp file=2]`inventoryServiceIp` is the same IP address value that you retrieved in the previous section that is assigned to the `inventory` service. This value will also be passed in when you run the tests. 

=== Running the tests

Run the Maven `verify` goal to test your microservices by replacing the `[system-EXTERNAL-IP]` with the value determined in the previous section.

[role='command']
```
mvn verify -Ddockerfile.skip=true -Dsystem.ip=[system-EXTERNAL-IP]
```

The `dockerfile.skip` parameter is set to `true` to skip building a new container image.

If the tests pass, you will see an output similar to the following for each service:

[role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.system.SystemEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.673 sec - in it.io.openliberty.guides.system.SystemEndpointTest

Results:

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----

[role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.inventory.InventoryEndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.222 sec - in it.io.openliberty.guides.inventory.InventoryEndpointTest

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Tearing down the environment
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed microservices, you can delete all {kube} resources 
by running the `kubectl delete` command:

[role='command']
```
kubectl delete -f kubernetes.yaml
```

Since you are done testing your cluster, clean up all of its related sources using the `az group delete` command.
This command will remove the resource group, container service, and all related resources.
However, deleting an AKS cluster does not delete the service principal that was automatically created and linked with your cluster. 

Get the `client-Id` of the service principal from the `az aks show` command, and then delete the service principal:

[role='command']
```
az aks show -g guideGroup -n guideCluster --query servicePrincipalProfile.clientId -o tsv
```

[role='command']
```
az ad sp delete --id [servicePrincipalProfile-clientId]
```

Delete the rest of your Azure resources:

[role='command']
```
az group delete --name guideGroup --yes --no-wait
```

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just deployed two microservices running in Open Liberty to Azure Kubernetes Service (AKS). You also 
learned how to use `kubectl` to deploy your microservices on a {kube} cluster.

// Multipane
include::{common-includes}/attribution.adoc[subs="attributes"]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
